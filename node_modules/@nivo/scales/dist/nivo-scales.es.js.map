{"version":3,"file":"nivo-scales.es.js","sources":["../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../src/ticks.ts"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = typeof timePrecisions[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = (scale as unknown) as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = (scale as unknown) as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return scale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseFloat(String(value)) as unknown) as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, (parseTime(value as Date) as unknown) as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"],"names":["arrayLikeToArray","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","defineProperty","timePrecisions","precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","format","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","data","size","axis","min","max","stacked","reverse","clamp","nice","minValue","minStacked","maxValue","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","createBandScale","round","scaleBand","castBandScale","createTimeScale","normalize","scaleUtc","scaleTime","createLogScale","base","hasZero","some","v","Error","sign","hasMixedSign","filter","Math","scaleLog","createSymlogScale","constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","nestSerieData","serie","map","d","getDatumAxisPosition","datum","stackedValue","computeXYScalesForSeries","series","xScaleSpec","yScaleSpec","width","height","nestedSeries","xy","generateSeriesXY","stackX","stackY","xScale","x","yScale","y","computedSeries","position","generateSeriesAxis","scaleSpec","getValue","setValue","parseFloat","String","values","push","sortBy","uniq","uniqBy","sort","last","stackAxis","otherAxis","compare","isDate","stack","find","stackValue","head","arrayWithHoles","iterableToArrayLimit","nonIterableRest","centerScale","bandwidth","offset","timeDay","timeInterval","step","getDate","start","end","floor","utcDay","setUTCHours","setUTCDate","getUTCDate","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","isInteger","isFinite","getScaleTicks","Array","isArray","matches","match","amount","timeType","originalStop","stop","every","Number","ticks","interval"],"mappings":"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"}